# Phase Auto-Execution Command

**Usage**: `/phase {number}` (예: `/phase 0.2`, `/phase 1`)

## 목적
REALPLAN.md의 특정 Phase를 자율적으로 실행합니다.

## 실행 로직

당신은 이제 **Autonomous Phase Executor**로 동작합니다.

### Step 1: Phase 분석
1. REALPLAN.md에서 요청된 Phase 번호의 태스크 목록 추출
2. 각 태스크의 의존성(dependency) 분석
3. 병렬 실행 가능한 그룹 식별

### Step 2: 실행 계획 생성
```
Phase {number} 실행 계획:

**병렬 그룹 1** (의존성 없음):
- Task A
- Task B
- Task C

**병렬 그룹 2** (그룹 1 완료 후):
- Task D (requires Task A)
- Task E (requires Task B, C)

**순차 그룹**:
- Task F (requires all previous)
```

### Step 3: 자율 실행
- **TodoWrite 도구 사용**: 모든 태스크를 todo list에 추가
- **Task 도구 사용**: 병렬 그룹은 단일 메시지에서 여러 Task 도구 호출
- **자동 검증**: 각 그룹 완료 후 결과 검증
- **자동 복구**: 실패 시 재시도 또는 대안 접근

### Step 4: 진행 상황 보고
각 그룹 완료 시:
```
✅ 병렬 그룹 1 완료 (3/3 성공)
- Task A: ✅ 완료
- Task B: ✅ 완료
- Task C: ✅ 완료

🚀 병렬 그룹 2 시작...
```

### Step 5: 최종 보고
Phase 완료 시:
```
🎉 Phase {number} 완료

**성과**:
- 총 6개 태스크 완료
- 실행 시간: 25분
- 생성 파일: 12개
- 코드 라인: 2,847줄

**다음 단계**:
- Phase {number+1} 실행 가능
- 또는 `/phase {number+1}` 명령으로 계속
```

## 자율 실행 규칙

### 1. 파일 생성/수정 자율권
- **사전 승인 불필요**: Phase 목표 달성에 필요한 모든 파일 생성/수정
- **예외**: 프로덕션 데이터베이스 변경, .env 파일 수정은 확인 필요

### 2. 에러 처리 자율권
- **자동 재시도**: 일시적 에러는 3회까지 자동 재시도
- **자동 디버깅**: 에러 발생 시 로그 분석 후 수정 시도
- **에스컬레이션**: 3회 실패 시 사용자에게 보고 및 해결책 제시

### 3. 의존성 해결 자율권
- **자동 설치**: 필요한 패키지는 자동으로 pyproject.toml/package.json에 추가
- **자동 마이그레이션**: 데이터베이스 스키마 변경 시 마이그레이션 스크립트 생성

### 4. 테스트 자율권
- **자동 테스트**: 코드 생성 후 관련 테스트 자동 실행
- **자동 수정**: 테스트 실패 시 코드 수정 시도
- **커버리지**: 주요 기능은 80% 이상 테스트 커버리지 목표

## 예시

### 사용자 입력
```
/phase 0.2
```

### AI 자율 실행
```
Phase 0.2 분석 완료: "오디오 생성 엔드투엔드 테스트 (30초/60초/180초)"

실행 계획:
**병렬 그룹 1**: 테스트 스크립트 준비
- 30초 테스트 스크립트 생성
- 60초 테스트 스크립트 생성
- 180초 테스트 스크립트 생성

**병렬 그룹 2**: 오디오 생성 실행
- 30초 오디오 생성
- 60초 오디오 생성
- 180초 오디오 생성

**순차 그룹**: 검증
- 생성된 오디오 길이 검증
- 정규화 품질 검증
- 보정 루프 정확도 검증

🚀 실행 시작...

[AI가 자율적으로 Task 도구를 사용하여 병렬 실행]
[AI가 자율적으로 결과 검증]
[AI가 자율적으로 보고서 생성]

✅ Phase 0.2 완료!
```

## 메타 학습

Phase 실행 후 자동으로 실행 패턴을 학습하고 CLAUDE.md에 추가:
- 자주 발생하는 에러 패턴과 해결책
- 효율적인 병렬화 전략
- Phase별 평균 실행 시간

이를 통해 다음 Phase 실행 시 더 효율적으로 동작합니다.
